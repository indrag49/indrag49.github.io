<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>A tutorial on simulating dynamical neurons using <code>Python</code></title>

<!-- Load MathJax -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

<!-- <p id="last-updated">Last updated: …</p>

<script>
// Change these to your GitHub user and repo name
const OWNER = 'indrag49';
const REPO  = 'indrag49.github.io';

fetch(`https://api.github.com/repos/${OWNER}/${REPO}/commits?path=index.html&page=1&per_page=1`)
  .then(res => res.json())
  .then(commits => {
    if (commits && commits.length > 0) {
      const date = new Date(commits[0].commit.committer.date);
      document.getElementById('last-updated')
        .textContent = 'Last updated: ' + date.toISOString().split('T')[0];
    }
  })
  .catch(err => {
    console.warn('Could not fetch GitHub commit date', err);
  });
</script> -->


<!-- Enable automatic equation numbering -->
<script>
window.MathJax = {
  tex: {
    tags: 'ams',  // 'ams' = automatic equation numbering like LaTeX
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']]
  }
};
</script>

<!-- Include Highlight.js for syntax highlighting -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

<style>
/* Center the code block */
.code-container {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 2em 0;
}

/* Styled code box with blue accent */
.code-box {
  background-color: #f8f9fa;             /* light background */
  border: 2px solid #d0e3ff;             /* soft blue outer border */
  border-left: 5px solid #1e90ff;        /* blue accent on left */
  border-radius: 8px;
  padding: 1em;
  width: 60%;
  max-width: 900px;
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.05);
}

/* Optional: monospace font and color tuning */
.code-box code {
  font-family: 'JetBrains Mono', 'Fira Code', monospace;
  font-size: 0.9rem;
}

table.centered {
    margin-left: auto;
    margin-right: auto;
    width: 60%;
    /* optional styling */
    border-collapse: collapse;
    border: 1px solid #ccc;
  }
  table.centered th,
  table.centered td {
    border: 1px solid #999;
    padding: 8px;
    text-align: center;
  }
  table.centered caption {
    caption-side: top;
    font-weight: bold;
    margin-bottom: 8px;
  }
</style>


</head>

<body>

<h1>A tutorial on simulating dynamical neurons using <code>Python</code>.</h1>

This blog could have been an email! However, I decided to take the longer road of explicitly breaking down each and every step I took to run simulations of neuron network models.
This blog is intended to teach the community how to run simulations of neuron models using <code>Python</code>. This blog could have been a journal article! I was just too lazy to go through all the hassles and instead dive into preparing this tutorial.


<hr>
<h2>Introduction</h2>

<p>We are interested in studying neurons as <em>dynamical systems</em>. In this tutorial we will talk about how neurons behave over time and how we can
utilise tools and techniques from dynamical systems literaure to study this exactly. Neurons are <em>excitable</em> cells which exhibit dynamic firing and
bursting patterns <a href="#HeYa21">[1]</a>. Neurons as dynamical systems is a field called <em>neurodynamics</em>, and has been extensively covered in the 
book by Izhikevich <a href="#Iz07">[2]</a>. We will consider the famous model of neuron dynamics by Fitzhugh and Nagumo <a href="#Fi61">[3]</a>.</p>

<p>
The model equations are given by
$$
\begin{equation}
\label{eq:model_single}
\begin{aligned}
    \dot{v} &= f(v, w) = v - \frac{v^3}{3} - w + I_{\rm ext}, \\
    \dot{w} &= g(v, w) = \frac{v + a - bw}{\tau}. \\
\end{aligned}
\end{equation}
$$
Each neuron is represented by two variables $(v, w)$. The membrane potential (or the voltage) is given by $v$ and the recovery variable is given by $w$.
The voltage $v$ is the "fast" variable which changes quickly on neuron firing, and $w$ is the "slow" variable that moderates bringing the neuron back to its initial state after firing.
Biophysically speaking, the variable $w$ models the reactivation of the sodium channel and deactivation of the potassium channel. The parameters are given in <a href="#tab:parameters">the table below</a>.
  
<table id="tab:parameters" class="centered">
  <caption>Parameters for the FitzHugh-Nagumo neuron model</caption>
  <thead>
    <tr><th>Symbol</th><th>Definition</th></tr>
  </thead>
  <tbody>
    <tr><td>$I_{\rm ext}$</td><td>External input current to the neuron</td></tr>
    <tr><td>$a$</td><td>Recovery shift parameter</td></tr>
    <tr><td>$b$</td><td>Recovery slope parameter</td></tr>
    <tr><td>$\tau$</td><td>Time‐scale separation (slow variable)</td></tr>
  </tbody>
</table>
Let us run a simulation to plot the phase portrait and time series of the neuron model. We will set $I_{\rm ext} = 0.5$, $a = 0.7$, $b = 0.8$, and $\tau = 12.5$.
Let us first import the necessary <code>Python</code> packages:
  
<div class="code-container">
  <div class="code-box">
<pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from matplotlib.gridspec import GridSpec
</code></pre>
  </div>
</div>

We require <a href="https://numpy.org/"><code>numpy</code></a> for accessing the linear algebra suite, <a href="https://matplotlib.org/"><code>matplotlib</code></a> for creating plots, 
and <a href="https://scipy.org/"><code>scipy</code></a> for accessing algorithms for performing scientific computing. Next we define the parameters in <code>Python</code>:

<div class="code-container">
  <div class="code-box">
<pre><code class="language-python">
a     = 0.7
b     = 0.8
tau   = 12.5
I_ext = 0.5
</code></pre>
  </div>
</div>

Next, we set up the environment for plotting the phase portrait and also define the "nullclines":

<div class="code-container">
  <div class="code-box">
<pre><code class="language-python">
x_vals = np.linspace(-2, 2, 300)
y_vals = np.linspace(-1, 3, 300)
X, Y   = np.meshgrid(x_vals, y_vals)

nullcline_v = X - (X**3)/3 + I_ext
nullcline_w = (X + a) / b
</code></pre>
  </div>
</div>

The next step is to define the FitzHugh-Nagumo system of ordinary differential equations governing the dynamics of a single neuron.
We write a <code>Python</code> function:

<div class="code-container">
  <div class="code-box">
<pre><code class="language-python">
def fhn_system(t, vars):
    v, w = vars
    dvdt = v - (v**3)/3 - w + I_ext
    dwdt = (v + a - b*w) / tau
    return [dvdt, dwdt]
</code></pre>
  </div>
</div>

We define the time duration and time steps:

<div class="code-container">
  <div class="code-box">
<pre><code class="language-python">
v0, w0 = -1.0, 1.0
t_span = (0, 500)
t_eval = np.linspace(t_span[0], t_span[1], 5000)
</code></pre>
  </div>
</div>

and solve the system of ODEs using the <code>solve_ivp()</code> function from <code>scipy</code>, which goes:

<div class="code-container">
  <div class="code-box">
<pre><code class="language-python">
sol = solve_ivp(fhn_system, t_span, [v0, w0], t_eval=t_eval, method='LSODA')
v_sol = sol.y[0]
w_sol = sol.y[1]
t_sol = sol.t
</code></pre>
  </div>
</div>
We collect the solutions in <code>v_sol</code>, <code>w_sol</code> and the time stamps <code>t_sol</code>. We have a few things to discuss here.
Given an initial condition, the <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html"><code>solve_ivp()</code> </a> function numerically integrates a system of ODEs.
There are several integration methods available for solving the equations. The most commonly used one is the '<code>RK45</code>' which is the Explicit Runge-Kutta method of order 5(4). See <a href="#DoPr90">[4]</a>.
The system of ODEs considered here have variables evolving in different timescales, thus can be stiff. So '<code>RK45</code>' can be inefficient.
Instead, we use '<code>LSODA</code>'. <code>LSODA</code> is a numerical solver originally written in <code>FORTRAN</code></code> as part of the <a href="https://computing.llnl.gov/projects/odepack"><code>ODEPACK</code></a> [<a href="#Hi83">5</a>, <a href="#Pe83">6</a>] collection.
<code>LSODA</code> works well for both stiff and non-stiff systems and can dynamically switch between them as per the problem provided. For non-stiff systems
it uses the Adams–Bashforth–Moulton predictor–corrector method   
</p> 

<!-- <img src="images/networkOnBrain.png" width="600"/> -->

<h2>The brain abstracted as a graph</h2>

<p>Billions of neurons form a complex topology to make up the functionalities of the brain. This complex topology can be abstracted as a graph.
See <a href="#fig-brain">Figure 1</a> for details for a schematic representation. This representation however is not exhaustive.
<figure style="text-align:center" id="fig-brain">
  <img src="images/networkOnBrain.png" width="450">
  <figcaption><b>Figure 1.</b> Erdős–Rényi network overlaid on the brain. (Brain schematic taken from WikiPedia)</figcaption>
</figure>
Each neuron, represented by a red node in <a href="#fig-brain">Figure 1</a> has its own internal dynamics governed by \(\ref{eq:model_single}\).
Because each neuron is dynamic, the whole network is a temporal network which evolves in time. The couplings (represneted by edges) can be 
either static or evolving, depending upon the topology one wants to analyse. 
</p>

<h2>Introduction to graphs and <code>NetworkX</code></h2>


Import the required packages.
<!-- <div class="code-container">
  <div class="code-box">
<pre><code class="language-python">
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.patches import Polygon
from matplotlib.collections import PatchCollection 
# import plotly.graph_objects as go
from matplotlib.patches import Circle
from scipy.integrate import solve_ivp
import nolds as nd
from scipy.optimize import curve_fit
from scipy.optimize import fsolve
from scipy.stats import pearsonr
import matplotlib.gridspec as gridspec
import pandas as pd

import lyapynov
from lyapynov import ContinuousDS, DiscreteDS
from lyapynov import mLCE, LCE, CLV, ADJ
</code></pre>
  </div>
</div> -->

<hr>
<h2>References</h2>
<ol id="references">
  <li id="HeYa21">
     F. He and Y. Yang, Nonlinear system identification of neural systems from neurophysiological signals, <em>Neuroscience</em>, 458, 213 (2021).
  </li>
  
  <li id="Iz07">
    E. Izhikevich, Dynamical Systems in Neuroscience (MIT Press, Cambridge, MA, 2007).
  </li>

  <li id="Fi61"> R. FitzHugh, Impulses and physiological states in theoretical models of nerve membrane, Biophys. J. 1, 445 (1961).</li>
  <li id="DoPr90"> J. R. Dormand, P. J. Prince, A family of embedded Runge-Kutta formulae, J. Comput. Appl. Math., Vol. 6, No. 1, pp. 19-26 (1980).</li>

  <li id="Hi83">A. C. Hindmarsh, “ODEPACK, A Systematized Collection of ODE Solvers,” IMACS Transactions on Scientific Computation, Vol 1., pp. 55-64 (1983).</li>
  <li id="Pe83">L. Petzold, “Automatic selection of methods for solving stiff and nonstiff systems of ordinary differential equations”, SIAM J. Sci. Stat. Comput. Vol. 4, No. 1, pp. 136-148 (1983).</li>
</ol>

</body>
</html>
